### **【完全单体应用】基于Java 21的分层架构设计文档**

#### **1. 项目概述**

本项目为一个企业级完全单体应用，旨在提供一个稳定、高效、易于维护的业务平台。我们将采用成熟的分层架构模式，利用业界主流的Java技术栈，构建一个高内聚、低耦合的系统。核心设计原则包括领域驱动设计思想的初步实践、严格的分层依赖、以及对RBAC权限模型和缓存策略的深度集成。

**技术栈**:

*   **核心框架**: Spring Boot 3.x (利用Java 21新特性)

*   **持久层**: Spring Data JPA, PostgreSQL

*   **缓存**: Spring Data Redis

*   **安全**: Spring Security, JWT (Json Web Token)

*   **构建工具**: Maven 或 Gradle

*   **其他**: Lombok (减少样板代码)

---

#### **2. 核心架构设计：分层架构**

系统整体采用严格的分层架构，数据流向单向清晰，确保各层职责明确，便于理解、测试和维护。

**架构层次与依赖关系**:

| 层次 | 核心职责 | 依赖关系 | 备注 |

| :--- | :--- | :--- | :--- |

| **表现层** | 处理HTTP请求/响应，参数校验，统一格式化输出，前端API入口。 | 依赖 **服务接口层** 和 **公共层** | |

| &nbsp;&nbsp;&nbsp;├─ **控制器层** | 接收并解析HTTP请求，调用服务层处理业务，封装并返回统一格式的JSON响应。**此处是权限控制的核心拦截点。** | 依赖 `Service Interface` | 职责：入口与出口。 |

| **服务层** | 实现核心业务逻辑，编排领域对象，管理事务，协调外部服务调用。 | 依赖 **数据访问层** 和 **公共层** | |

| &nbsp;&nbsp;&nbsp;├─ **服务接口层** | 定义业务逻辑的抽象契约，不含实现。 | 依赖 `Repository`, `Entity` | 职责：面向接口编程。 |

| &nbsp;&nbsp;&nbsp;└─ **服务实现层** | 实现服务接口中定义的所有业务逻辑。 | 实现 `Service Interface` | 职责：用例编排。 |

| **数据访问层** | 负责与数据库和缓存进行交互，实现数据的持久化和查询。 | 依赖 **公共层** 的 `Entity` | |

| &nbsp;&nbsp;&nbsp;├─ **数据库接口层** | 定义数据持久化操作的抽象，通过JPA/MyBatis动态代理实现。 | 操作 `Entity` | 职责：数据持久化契约。 |

| &nbsp;&nbsp;&nbsp;└─ **数据传输层** | 在此特指为服务层与数据库交互定制的DTO，用于承载复杂查询结果。 | 作为数据载体 | 职责：复杂数据传递。 |

| **公共层** | 提供贯穿全系统的共享模型、配置和工具类，是整个应用的基础。 | 无依赖，被其他所有层依赖 | |

| &nbsp;&nbsp;&nbsp;├─ **实体层** | 包含JPA实体（与数据库表映射）和核心业务领域模型（如RBAC模型）。 | 无 | 职责：业务领域核心。 |

| &nbsp;&nbsp;&nbsp;└─ **工具类层** | 封装通用功能，如JWT处理、Redis操作、日期工具等。 | 无 | 职责：提供复用能力。 |

---

#### **3. 核心模块与关键技术实现**

**3.1. 权限控制 - RBAC模型 (不造轮子)**

*   **数据模型 (实体层)**:

    *   `Permission` (权限表): `id`, `name` (e.g., `system:user:create`), `description`

    *   `Role` (角色表): `id`, `name` (e.g., `ROLE_ADMIN`), `description`

    *   `User` (用户表): `id`, `username`, `password` (BCrypt加密), `status`

    *   **关联关系**: `Role` 和 `Permission` 是多对多；`User` 和 `Role` 是多对多。

*   **认证与授权流程**:

    1.  **登录**: 用户携带用户名密码请求登录。`AuthService` 校验密码，成功后生成包含用户ID、角色、权限的 **JWT Token** 返回给客户端。

    2.  **请求授权**: 客户端在后续请求的 `Authorization` 头中携带 **Bearer Token**。

    3.  **拦截与解析**: **Spring Security** 拦截所有请求，通过 **JWT Filter** 解析、验证 **Token** 的有效性。

    4.  **上下文构建**: 验证通过后，将用户信息（认证主体、权限列表）存入 `SecurityContext`，供后续流程使用。

    5.  **方法级权限**: 在 **Controller** 方法上使用 **`@PreAuthorize`** 注解进行权限控制。例如：`@PreAuthorize("hasAuthority('system:user:create')")`。Spring Security会根据`SecurityContext`中的信息动态决定是否放行。

**3.2. 数据持久化 - JPA与PostgreSQL**

*   **实体映射**: 所有数据库表均通过JPA注解（`@Entity`, `@Table`, `@Column`）映射为Java实体类。

*   **Repository接口**: 继承 `JpaRepository<T, ID>` 获得标准CRUD、分页、排序能力。

*   **自定义查询**: 优先使用方法名查询（如 `findByUsername`），复杂查询则使用 `@Query` 注解定义JPQL或原生SQL。

**3.3. 缓存策略 - Redis**

*   **定位**: Redis作为二级缓存，主要用于缓存热点数据、减轻数据库压力和提升系统性能。

*   **模式**: 采用 **Cache-Aside (旁路缓存)** 模式。

*   **实现**:

    *   **读逻辑**: 先查缓存，若未命中则查询数据库，并将结果写回缓存。

    *   **写/删逻辑**: 先更新/删除数据库，然后**主动**删除或更新缓存。

*   **技术实现**: 使用Spring Cache抽象，通过 `@Cacheable` (读/写), `@CachePut` (更新), `@CacheEvict` (删除) 注解在服务层方法上，声明式地管理缓存。

**3.4. 统一API响应**

*   **设计**: 所有API接口，无论成功或失败，均返回统一格式的JSON对象。

*   **结构示例**:

    ```json

    // 成功

    {

      "code": 200,

      "message": "操作成功",

      "data": { "userId": 123, "username": "test" }

    }

    // 失败

    {

      "code": 400,

      "message": "请求参数错误",

      "data": null

    }

    ```

*   **实现**: 通过一个全局异常处理器（`@ControllerAdvice` + `@ExceptionHandler`）和统一的响应模型类（`ApiResponse<T>`）来强制执行。

---

#### **4. 关键设计原则**

1.  **领域驱动设计**: 将核心业务逻辑封装在`Entity`和`Service`中，`Entity`代表业务领域对象，`Service`负责协调用例，将技术与业务解耦。

2.  **关注点分离**: 每个组件职责单一。`Controller`只处理HTTP，`Service`只处理业务，`Repository`只处理数据，`DTO`只负责数据传递。

3.  **依赖倒置**: 高层模块（`Controller`）依赖低层模块（`Service`）的抽象（接口），而非具体实现。这是实现松耦合的关键。

4.  **无状态**: 认证通过JWT实现，服务层应设计为无状态，不依赖Session，便于水平扩展。

---

#### **5. 数据流向详解 (以“创建用户”用例为例)**

1.  **请求**: 前端发送 `POST /api/users` 请求，Body中包含用户信息。

2.  **入口与权限**: `UserController` 接收请求。`@PreAuthorize` 注解校验当前用户是否拥有创建用户的权限。

3.  **转换与校验**: 请求体被反序列化为 `UserCreateRequestDTO`。框架自动进行JSR 303格式校验。

4.  **业务编排**: `UserServiceImpl` 的 `createUser` 方法（标记`@Transactional`）被调用。

    *   校验用户名是否已存在。

    *   将DTO转换为 `User` 实体。

    *   对密码进行BCrypt加密。

5.  **数据持久化**: 调用 `userRepository.save()` 将 `User` 实体持久化到PostgreSQL。事务提交。

6.  **缓存更新**: （可选）如果配置了用户缓存，使用 `@CacheEvict` 清除相关缓存。

7.  **响应**: 返回新创建的 `User` 实体，被转换为 `UserDTO`，并封装进统一的 `ApiResponse` 中返回给客户端。

---

#### **6. 项目包结构建议**

```

com.yourcompany.yourapp

├── common/                              // 公共模块

│   ├── config/                          // 核心配置类

│   │   ├── SecurityConfig.java          // Spring Security + JWT 配置

│   │   ├── RedisConfig.java             // Redis连接与缓存配置

│   │   └── JpaConfig.java               // JPA相关配置

│   ├── entity/                          // 实体与领域模型

│   │   ├── User.java, Role.java, ...   // JPA实体

│   │   └── ...                          // 其他领域模型

│   ├── dto/                             // 数据传输对象

│   │   ├── request/                      // 请求DTO

│   │   └── response/                     // 响应DTO

│   └── utils/                           // 工具类

│       ├── JwtUtils.java                // JWT生成与解析

│       └── ...

│

├── controller/                          // 控制器层

│   ├── UserController.java

│   └── ...

│

├── service/                             // 服务层

│   ├── service/                         // 服务接口

│   │   ├── UserService.java

│   │   └── ...

│   └── serviceimpl/                     // 服务实现

│       ├── UserServiceImpl.java

│       └── ...

│

└── repository/                          // 数据访问层

    ├── UserRepository.java

    └── ...

```

此架构设计文档定义了项目的骨架和核心规则，后续所有开发活动均应以此为基准，确保项目的一致性和高质量。  先生成一部分 关键架构设计  就架构就好